{
  "name": "Validator.js",
  "tagline": "Powerful objects and strings validation in javascript for Node and the browser ",
  "body": "# validator.js\r\n\r\nPowerful objects and strings validation in javascript for Node and modern browsers (evergreen browsers).\r\n\r\n## Version\r\n\r\n1.2.3\r\n\r\n## Status\r\n\r\n[![Build Status](https://travis-ci.org/guillaumepotier/validator.js.png?branch=master)](https://travis-ci.org/guillaumepotier/validator.js)\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/guillaumepotier/validator.js/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n## License\r\n\r\nMIT - See LICENSE.md\r\n\r\n## Install\r\n\r\n`bower install validator.js`\r\n\r\n# Summary\r\n\r\n  - [General usage](#general-usage)\r\n  - [Validate string](#validate-a-string)\r\n  - [Validate object](#validate-an-object)\r\n  - [Validation groups](#validation-groups)\r\n  - [Bind constraint to an object](#bind-a-constraint-to-an-object)\r\n  - [Assert definition](#assert-definition)\r\n  - [Constraint definition](#constraint-definition)\r\n  - [Available asserts](#available-asserts)\r\n  - [Collection Assert](#collection-assert)\r\n  - [Callback Assert](#callback-assert)\r\n\r\n## General usage\r\n\r\n- On node:\r\n\r\n```\r\n$ npm install -g validator.js\r\n```\r\n\r\nThen\r\n\r\n```js\r\nvar Validator = require( 'validator.js' );\r\n```\r\n\r\n- On browser:\r\n\r\n```js\r\n<script src=\"../validator.js\"></script>\r\n<script>\r\n    console.log(Validator);\r\n</script>\r\n```\r\n\r\n## Validate a string\r\n\r\n```js\r\nvar is = require( 'validator.js' ).Assert;\r\nvar validator = require( 'validator.js' ).validator();\r\n\r\nvalidator.validate( 'foo', is.ofLength( { min: 4 } ) );\r\nvalidator.validate( 'foo', [ is.ofLength( { min: 4 } ), is.email() ] );\r\n```\r\n\r\nwill return `true` if validation passes, a `Violation`'s array otherwise.\r\n\r\n## Validate an object\r\n\r\n```js\r\nvar is = require( 'validator.js' ).Assert;\r\nvar validator = require( 'validator.js' ).validator();\r\n\r\nvar object = {\r\n    name: 'john doe',\r\n    email: 'wrong@email',\r\n    firstName: null,\r\n    phone: null\r\n  },\r\n  constraint = {\r\n    name: [ is.notBlank(), is.ofLength( { min: 4, max: 25 } ) ],\r\n    email: is.email(),\r\n    firstName: is.notBlank(),\r\n    phone: is.notBlank()\r\n  };\r\n\r\nvalidator.validate( object, constraint );\r\n```\r\n\r\nwill return `true` if validation passes, `{ email: [ Violation ], firstname: [ Violation ] }` in this case.\r\n\r\n## Validation groups\r\n\r\nWith same objects than above, just by adding validation groups:\r\n\r\n```js\r\n  constraint = {\r\n    name:      [ is.notBlank(), is( 'edit' ).ofLength( { min: 4, max: 25 } ) ],\r\n    email:     is.email(),\r\n    firstname: is( [ 'edit', 'register'] ).notBlank(),\r\n    phone:     is( 'edit' ).notBlank()\r\n  };\r\n\r\nvalidator.validate( object, constraint, 'edit' );\r\n```\r\n\r\nwill return `true` in this case `{ firstname: [ Violation ], phone: [ Violation ] }`.\r\n\r\nThere are two special groups: \"Any\" and \"Default\". Validating against `\"Any\"` group will validate\r\nagainst all Asserts, regardless their groups. Validating against `\"Default\"` group will only\r\nvalidate against Asserts that do not have a validation group.\r\n\r\n## Bind a constraint to an object\r\n\r\n```js\r\nvalidator.bind( object, constraint );\r\nvalidator.validate( object, groups );\r\n```\r\n\r\nUnder the hood, by default, a `_validatorjsConstraint` key will be created in object\r\nin order to store here the constraint. You could override this default key name by\r\npassing an option to Validator constructor.\r\n\r\n# Documentation\r\n\r\n## Assert definition\r\n\r\nAn assert implements Assert Interface, and is an assertion that your string or object\r\nproperty must pass during validation process. There are several Asserts built in\r\nValidator.js (see below), but you can implement yours for your needs using the\r\n`Callback()` assert (see below).\r\n\r\n```js\r\nvar length = is.ofLength( { min: 10 } );\r\ntry {\r\n  length.check( 'foo' );\r\n} catch ( violation ) {\r\n}\r\n```\r\n\r\n## Constraint definition\r\n\r\nA Constraint is a set of asserts nodes that would be used to validate an object.\r\n\r\n```js\r\nvar length = is.ofLength( { min: 10 } );\r\nvar notBlank = is.notBlank();\r\nvar constraint = validator.constraint( { foo: length, bar: notBlank } );\r\n\r\nconstraint.check( { foo: 'foo', bar: 'bar' } );\r\n```\r\n\r\n### Strict Constraint validation\r\n\r\nBy default, Validator.js checks properties that are defined in the Constraint object\r\nand exists on the validated object unless the constraint is `Required`. If you want a\r\nstrict validation (ie ensure that **every**) Constraint node is valid, you'll have to pass\r\nan optional parameter to your Constraint:\r\n\r\n```js\r\nvar object = {\r\n  foo: 'foo',\r\n  bar: 'bar'\r\n};\r\n\r\nvar constraint = validator.constraint( {\r\n  foo: is.notBlank(),\r\n  bar: is.notBlank(),\r\n  baz: is.notBlank()\r\n}, { strict: true });\r\n\r\nconstraint.check( object );\r\n```\r\nwill return a `HaveProperty` Violation, saying that `baz` property does not exist\r\nin validated object. Without `{ strict: true }` this check would return `true`.\r\n\r\n### Deep required validation\r\n\r\nBy default, a `Required` constraint fails if the parent property exists in the validated\r\nobject and the property doesn't. To force Validator.js to take into account all `Required`\r\nconstraints, no matter the validated object, you have to enable the `deepRequired` option:\r\n\r\n```js\r\nvar object = { };\r\n\r\nvar constraint = validator.constraint({\r\n  foo: {\r\n    bar: is.required()\r\n  }\r\n}, { deepRequired: true });\r\n\r\nconstraint.check(object);\r\n```\r\n\r\nwill return a `HaveProperty` Violation, saying that `foo` property does not exist.\r\n\r\nThis option also works when `Collection` is used, but doesn't enforce a non empty array\r\non the validated object.\r\n\r\n## Available asserts\r\n\r\n- Blank() (alias: `blank`)\r\n- Callback( fn ( value ) {} [, arg1 ...] ) (alias: `callback`)\r\n- Choice( [] ) (alias: `choice`)\r\n- Choice( fn () {} ) (alias: `choice`)\r\n- Collection ( Assert ) (alias: `collection`)\r\n- Collection ( Constraint ) (alias: `collection`)\r\n- Count( value ) (alias: `count`)\r\n- Count( fn ( [] ) {} ) (alias: `count`)\r\n- Email() (alias: `email`)\r\n- EqualTo( value ) (alias: `equalTo`)\r\n- EqualTo( fn ( value ) {} ) (alias: `equalTo`)\r\n- GreaterThan( threshold ) (alias: `greaterThan`)\r\n- GreaterThanOrEqual( threshold ) (alias: `greaterThanOrEqual`)\r\n- InstanceOf( classRef ) (alias: `instanceOf`)\r\n- IsString() (alias: `isString`)\r\n- Length( { min: value, max: value } ) (alias: `length`)\r\n- HaveProperty( propertyName ) (alias: `haveProperty`)\r\n- LessThan( threshold ) (alias: `lessThan`)\r\n- LessThanOrEqual( threshold ) (alias: `lessThanOrEqual`)\r\n- EqualTo( value ) (alias: `equalTo`)\r\n- EqualTo( fn ( value ) {} ) (alias: `equalTo`)\r\n- NotBlank() (alias: `notBlank`)\r\n- NotEqualTo( value ) (alias: `notEqualTo`)\r\n- NotNull() (alias: `notNull`)\r\n- Null() (alias: `null`)\r\n- Range( min, max ) (alias: `range`)\r\n- Regexp( value ) (alias: `regexp`)\r\n- Required() (alias: `required`)\r\n- Unique() (alias: `unique`)\r\n- Unique( { key: value } ) (alias: `unique`)\r\n\r\n### Additional asserts via extras.js\r\n\r\n- Eql( object ) (alias: `eql`)\r\n- Eql( fn ( value ) {} ) (alias: `eql`)\r\n- IPv4() (alias: `ipv4`)\r\n- Mac() (alias: `mac`)\r\n\r\n### Community-driven asserts\r\n\r\nYou can extend validator.js with more asserts should you need them. There are several extra asserts built by the community that seamlessly integrate with this package.\r\nSee the [Extending](#extending) section for more information.\r\n\r\n* [validator.js-asserts](https://github.com/seegno/validator.js-asserts): a set of extra asserts for `validator.js`.\r\n\r\n### Collection Assert\r\n\r\nCollection Assert is quite special yet powerful. It allows you to validate\r\nan object's array by checking each one of them against a constraint.\r\n\r\nHere is an example of test suite test showing how this assert works:\r\n\r\n```js\r\nit( 'Collection', function () {\r\n  var itemConstraint = validator.constraint( { foobar: is.notNull(), foobaz: is.notNull() } ),\r\n    object = {\r\n      foo: null,\r\n      items: [\r\n        { foobar: null, foobaz: 'foo', fooqux: null },\r\n        { foobar: 'bar', foobaz: 'baz' },\r\n        { foobar: null, foobaz: null }\r\n      ]\r\n    },\r\n    constraint = {\r\n      foo: is.notNull(),\r\n      items: [ is.collection( itemConstraint ), is.count( 2 ) ]\r\n    };\r\n\r\n  var result = validator.validate( object, constraint );\r\n  expect( result ).to.have.key( 'foo' );\r\n  expect( result ).to.have.key( 'items' );\r\n  expect( result.items[ 0 ] ).to.have.key( '0' );\r\n  expect( result.items[ 0 ] ).to.have.key( '2' );\r\n  expect( result.items[ 0 ][ 0 ] ).to.have.key( 'foobar' );\r\n  expect( result.items[ 0 ][ 0 ] ).not.to.have.key( 'foobaz' );\r\n  expect( result.items[ 0 ][ 2 ] ).to.have.key( 'foobar' );\r\n  expect( result.items[ 0 ][ 2 ] ).to.have.key( 'foobaz' );\r\n  expect( result.items[ 1 ] ).to.be.a( Violation );\r\n  expect( result.items[ 1 ].assert ).to.be( 'Count' );\r\n} )\r\n```\r\n\r\n### Callback Assert\r\n\r\nThis assert allows you to add the custom rules / assert you want. Just give a\r\ncallback function that will be called with the value to be tested against.\r\nReturn true for validation success, everything else if there is an error.\r\n\r\nHere is an example from test suite test showing how this assert works:\r\n\r\n```js\r\nit( 'Callback', function () {\r\n  assert = is.callback( function ( value ) {\r\n    var calc = ( 42 / value ) % 2;\r\n\r\n    return calc ? true : calc;\r\n  } );\r\n\r\n  expect( validate( 3, assert ) ).not.to.be( true );\r\n  expect( validate( 3, assert ).show() ).to.eql( { assert: 'Callback', value: 3, violation: { result: 0 } } );\r\n  expect( validate( 42, assert ) ).to.be( true );\r\n\r\n  // improved Callback\r\n  assert = is.callback( function ( value, string1, string2 ) {\r\n    return value + string1 + string2 === 'foobarbaz';\r\n  }, 'bar', 'baz' );\r\n  expect( validate( 'foo', assert ) ).to.be( true );\r\n  expect( validate( 'bar', assert ) ).to.be( false );\r\n} )\r\n```\r\n\r\n### A note on type checking\r\nNote that `Length` assertion works for both String and Array type, so if you want to validate only strings, you should write an additional assertion:\r\n\r\n```js\r\nvalidator.validate( 'foo', [\r\n  is.ofLength( { min: 4, max: 100 } ),\r\n  is.string()\r\n] );\r\n```\r\n\r\n## Extending\r\n\r\nIf you want to extend the library with your own asserts, you can use `Assert.extend()` which will return a copy of `validator.Assert` plus your custom asserts. This means that the original `validator.Assert` is always pristine.\r\n\r\nExample:\r\n\r\n```js\r\nvar Assert = Validator.Assert;\r\nvar isExtended = Assert.extend({\r\n  integer: Number.isInteger,\r\n  NaN: Number.isNaN\r\n});\r\n\r\nexpect( validate( 10, isExtended.integer() ).to.be( true );\r\n```\r\n\r\n## Run Tests\r\n\r\n- On node:\r\n  - `mocha tests/server.js`\r\n\r\n- On browser:\r\n  - open tests/browser.html in your browser\r\n",
  "google": "UA-41082541-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}